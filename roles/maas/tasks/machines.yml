---
################################################################################
# API base
################################################################################
- name: Set MAAS API base URL
  set_fact:
    _maas_api: "{{ maas_api_url | trim('/') }}/MAAS/api/2.0"

- include_tasks: _auth_header.yml

- include_tasks: machines/_read_machines.yml

- include_tasks: machines/_build_indexes.yml

- name: Ensure short hostnames are unique in MAAS
  fail:
    msg: "Duplicate short hostnames found in MAAS: {{ (_short_names | difference(_short_names | unique)) | unique | join(', ') }}"
  when: (_short_names | difference(_short_names | unique)) | length > 0

# (Shared) initialize the list of nodes we will un-break later
- name: Init shared _marked_broken list
  set_fact:
    _marked_broken: "{{ hostvars['localhost']._marked_broken | default([]) }}"
  delegate_to: localhost
  run_once: true

- include_tasks: machines/_plan_sets.yml

#- name: Include create.yml for missing hosts
#  include_tasks: machines/create.yml
#  loop: "{{ _create_names }}"
#  loop_control:
#    label: "{{ item }}"
#  vars:
#    host: "{{ item }}"
#    system_id: "{{ maas_short_to_id[item] | default(omit) }}"
#    # If inventory uses FQDNs, this resolves to the inventory hostname; else returns the short
#    inv_host: "{{ (inventory_by_short | default({})).get(item, item) }}"
#
##    desired_pool: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_machine_pool | default(_pool_from_groups) }}"
#    desired_arch: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_arch | default(maas_arch | default('amd64/generic')) }}"
#    desired_domain: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_domain | default(maas_domain | default(omit)) }}"
#    mac_addresses: >-
#      {{
#        (hostvars[(inventory_by_short | default({})).get(item, item)].maas_interfaces | default([]))
#        | map(attribute='prefix')
#        | map('regex_replace', '$', '_mac')
#        | map('extract', hostvars[(inventory_by_short | default({})).get(item, item)])
#        | select('defined')
#        | list
#      }}
#  tags: create_machines

# CREATE: loop over SHORT names only
- name: Include create.yml for missing hosts
  include_tasks: machines/create.yml
  loop: "{{ _create_short }}"
  loop_control:
    label: "{{ item }}"
  vars:
    # short name we planned against
    host: "{{ item }}"

    # creating: there should be no system_id; keep safe default
    system_id: "{{ maas_short_to_id[item] | default(omit) }}"

    # resolve inventory host (FQDN if inventory uses it)
    inv_host: "{{ (inventory_by_short | default({})).get(item, item) }}"

    desired_arch: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_arch
                     | default(maas_arch | default('amd64/generic')) }}"
    desired_domain: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_domain
                       | default(maas_domain | default(omit)) }}"

    # collect MACs from inventory: for each iface prefix, read <prefix>_mac var
    mac_addresses: >-
      {{
        (hostvars[(inventory_by_short | default({})).get(item, item)].maas_interfaces | default([]))
        | map(attribute='prefix')
        | map('regex_replace', '$', '_mac')
        | map('extract', hostvars[(inventory_by_short | default({})).get(item, item)])
        | select('defined')
        | list
      }}
  tags: create_machines

# Create machines just creates a skeleton machine entry.
# We called a handler to re-read all the machines from MaaS and update
# the _update_names list.
- meta: flush_handlers

- name: Set timestamp for when machines get marked broken
  set_fact:
    broken_at: "{{ lookup('pipe', 'date +%Y-%m-%d\\ %H:%M:%S') }}"

- include_tasks: machines/_plan_sets.yml

# UPDATE: loop over SHORT names only
- name: Include update.yml for existing hosts
  include_tasks: machines/update.yml
  loop: "{{ _update_short }}"
  loop_control:
    label: "{{ item }}"
  vars:
    # MAAS object for this short name (safe default to {})
    existing: "{{ maas_by_short[item] | default({}) }}"

    # updating requires a real system_id; keep strict so we notice problems
    system_id: "{{ maas_short_to_id[item] }}"

    # status map may be absent during initial runs; keep safe default
    system_status: "{{ maas_host_to_status[item] | default('Unknown') }}"

    host: "{{ item }}"
    inv_host: "{{ (inventory_by_short | default({})).get(item, item) }}"

    desired_arch: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_arch
                     | default(maas_arch | default('amd64/generic')) }}"
    desired_domain: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_domain
                       | default(maas_domain | default(omit)) }}"
  tags: update_machines

- pause:

#- name: Include update.yml for existing hosts
#  include_tasks: machines/update.yml
#  loop: "{{ _update_names }}"
#  loop_control:
#    label: "{{ item }}"
#  vars:
#    existing: "{{ maas_by_short[item] | default({}) }}"
#    system_id: "{{ maas_short_to_id[item] }}"
#    system_status: "{{ maas_host_to_status[item] }}"
#    host: "{{ item }}"
#    # If inventory uses FQDNs, this resolves to the inventory hostname; else returns the short
#    inv_host: "{{ (inventory_by_short | default({})).get(item, item) }}"
#
##    desired_pool: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_machine_pool | default(_pool_from_groups) }}"
#    desired_arch: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_arch | default(maas_arch | default('amd64/generic')) }}"
#    desired_domain: "{{ hostvars[(inventory_by_short | default({})).get(item, item)].maas_domain | default(maas_domain | default(omit)) }}"
#  tags: update_machines

- include_vars: "{{ secrets_path }}/ipmi.yml"
  failed_when: false

# Apply IPMI creds for all hosts we can resolve to a system_id
- name: Include set_ipmi_creds.yml
  include_tasks: machines/set_ipmi_creds.yml
  loop: "{{ _ipmi_with_id | default([]) }}"
  loop_control:
    loop_var: ipmi_short
    label: "{{ ipmi_short }}"
  vars:
    host: "{{ ipmi_short }}"                                     # short name
    system_id: "{{ maas_short_to_id[ipmi_short] }}"              # guaranteed by pre-filter
    # If inventory uses FQDNs, resolve to inventory hostname; else short
    inv_host: "{{ (inventory_by_short | default({})).get(ipmi_short, ipmi_short) }}"
  when:
    - power_user is defined
    - power_pass is defined
  tags:
    - ipmi


- name: Include delete.yml for extra hosts
  include_tasks: machines/delete.yml
  loop: "{{ _delete_names }}"
  loop_control:
    label: "{{ item }}"
  vars:
    host: "{{ item }}"
    system_id: "{{ maas_short_to_id[item] }}"
    # If inventory uses FQDNs, this resolves to the inventory hostname; else returns the short
    inv_host: "{{ (inventory_by_short | default({})).get(item, item) }}"
  when: (maas_delete_hosts | default(false)) | bool

- name: Include cleanup.yml when we marked nodes broken
  include_tasks: machines/cleanup.yml
  when: _marked_broken | default([]) | length > 0
  run_once: true
