---
# These zap tasks are run on freshly reimaged cobbler_managed machines
# even when using the -stock profiles.  Therefore, testnode package
# installation hasn't happened yet so we install zap dependencies here.

- name: Make sure apt dependencies are installed
  apt:
    name: ['gdisk', 'dmsetup']
    state: present
  when: ansible_os_family == "Debian"

- name: Make sure rpm dependencies are installed
  package:
    name: ['gdisk', 'device-mapper']
    state: present
  when: (ansible_distribution == "RedHat" and rhsm_registered is defined and rhsm_registered == true) or
        (ansible_os_family == "RedHat" and ansible_distribution != "RedHat")

# Prefer /boot or /boot/efi if present, otherwise fall back to /
- name: Determine device backing the OS
  set_fact:
    _os_device: >-
      {{
        (
          ansible_mounts
          | selectattr('mount', 'in', ['/boot', '/boot/efi'])
          | map(attribute='device')
          | list
          | first
        )
        | default(
          (
            ansible_mounts
            | selectattr('mount', 'equalto', '/')
            | map(attribute='device')
            | list
            | first
          ),
          true
        )
      }}

- name: Normalize OS disk (strip /dev/ and partition suffix)
  set_fact:
    # e.g.
    #  /dev/nvme0n1p1 -> nvme0n1
    #  /dev/sda1      -> sda
    #  /dev/nvme0n1   -> nvme0n1
    root_disk: >-
      {{
        _os_device
        | regex_replace('^/dev/', '')
        | regex_replace('p?[0-9]+$', '')
      }}

# Build unified list of disks that must never be zapped
- name: Build unified list of disks that must never be zapped
  set_fact:
    zap_skip_disks: >-
      {{
        [root_disk] +
        (ansible_devices.keys() | select('match', '^(loop|ram|sr)') | list) +
        (ansible_devices.keys() | select('match', '^dm-') | list)
      }}

- name: Default zap_disks to all zappable disks when not provided
  set_fact:
    zap_disks: >-
      {{
        ansible_devices.keys()
        | difference(zap_skip_disks | default([]))
        | list
      }}
  when: zap_disks is not defined or zap_disks | length == 0

- name: Debug zap_disks
  debug:
    var: zap_disks

- name: Ensure /var/lib/ceph is not mounted
  ansible.posix.mount:
    path: /var/lib/ceph
    state: unmounted

- name: Unmount any non-root mountpoints
  mount:
    path: "{{ item.mount }}"
    state: unmounted
  loop: "{{ ansible_mounts }}"
  when:
    - item.mount != '/'
    - not item.mount is match("/(boot|home|opt|root|srv|tmp|usr/local|var|.snapshots|snap)")

###############################################################################
# Hierarchical LVM teardown
###############################################################################

# Find PVs on zap_disks (match whole disk or nvme partition form)
- name: List PVs on zap_disks only
  shell: |
    DISKS="{{ zap_disks | join('|') }}"
    pvs --no-headings -o pv_name \
      | awk '{print $1}' \
      | egrep "^/dev/(${DISKS})(p?[0-9]+)?$" || true
  register: pvs_to_remove
  changed_when: false
  failed_when: false

# Find VGs that use those PVs
- name: Find VGs on zap_disks
  shell: |
    DISKS="{{ zap_disks | join('|') }}"
    pvs --no-headings --separator ',' -o pv_name,vg_name \
      | awk -F',' '{gsub(/^ *| *$/,"",$1); gsub(/^ *| *$/,"",$2); print $1" "$2}' \
      | egrep "/dev/(${DISKS})(p?[0-9]+)?$" \
      | awk '{print $2}' | sort -u || true
  register: zap_vgs
  changed_when: false
  failed_when: false

- name: Debug LVM objects on zap_disks
  debug:
    msg:
      pvs: "{{ pvs_to_remove.stdout_lines | default([]) }}"
      vgs: "{{ zap_vgs.stdout_lines | default([]) }}"

# Deactivate VGs (best-effort but should normally work)
- name: Deactivate VGs on zap_disks
  shell: "vgchange -an {{ item }}"
  loop: "{{ zap_vgs.stdout_lines | default([]) }}"
  when: (zap_vgs.stdout_lines | default([]) | length) > 0
  register: vgchange_out
  changed_when: false
  failed_when: false

# Remove VGs (and their LVs)
- name: Remove VGs (and LVs) on zap_disks
  shell: "vgremove -ff {{ item }}"
  loop: "{{ zap_vgs.stdout_lines | default([]) }}"
  when: (zap_vgs.stdout_lines | default([]) | length) > 0
  register: vgremove_out
  changed_when: true
  failed_when: false

# Remove PVs (after VG removal)
- name: Remove PVs on zap_disks
  shell: "pvremove --force --force --yes {{ item }}"
  loop: "{{ pvs_to_remove.stdout_lines | default([]) }}"
  when: (pvs_to_remove.stdout_lines | default([]) | length) > 0
  register: pvremove_out
  changed_when: true
  failed_when: false

###############################################################################
# Device Mapper cleanup
###############################################################################

- name: Find dm (lvm) devices on zap_disks (after VG/PV removal)
  shell: |
    for d in {{ zap_disks | join(' ') }}; do
      lsblk -rno NAME,TYPE,PKNAME \
        | awk -v dev="$d" '$2 == "lvm" && $3 == dev {print $1}'
    done | sort -u
  register: dm_on_zap_disks
  changed_when: false
  failed_when: false

- name: Remove dm devices on zap_disks
  command: "dmsetup remove {{ item }}"
  loop: "{{ dm_on_zap_disks.stdout_lines | default([]) }}"
  register: dm_remove
  changed_when: dm_remove.rc == 0
  failed_when: false

- name: Fail if any dm device is busy
  fail:
    msg: >-
      dmsetup remove hit "Device or resource busy" for:
      {{ dm_remove.results
         | selectattr('stderr', 'defined')
         | selectattr('stderr', 'search', 'Device or resource busy')
         | map(attribute='item')
         | list
      }}
  when: >
    (dm_remove.results | default([]) |
     selectattr('stderr', 'defined') |
     selectattr('stderr', 'search', 'Device or resource busy') |
     list | length) > 0

###############################################################################
# Finally, zap the bare drives
###############################################################################

- name: Zap GPT on zap_disks only
  shell: "sgdisk --zap-all /dev/{{ item }} || sgdisk --zap-all /dev/{{ item }}"
  loop: "{{ zap_disks }}"
  changed_when: true

- name: Blow away lingering OSD data and FSIDs (zap_disks only)
  shell: "dd if=/dev/zero of=/dev/{{ item }} bs=1M count=110"
  loop: "{{ zap_disks }}"
  changed_when: true
